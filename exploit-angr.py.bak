import angr, argparse, IPython
import claripy
'''
    Just a helper function to grab function names from resolved symbols.
    This will not be so easy if the binary is stripped.  You will have to
    open the binary in a disassembler and find the addresses of the
    functions you are trying to find/avoid in your paths rather than using
    this helper function.
'''



def untilFun(sm):
    #print(dir(sm.stashes),hex(sm.active[0].addr))
    if sm.active[0].addr == 0x43434343:
        print(vars(sm.active[0].history))
        return True
def nothing(state):
    pass
def main():
    elf_binary ="vuln_stackoverflow-medium"
    p = angr.Project(elf_binary, load_options={'auto_load_libs': False})
    #p.hook(0x4011a5, nothing, length=4)

    addr_main = p.loader.find_symbol("main").rebased_addr

    argv = claripy.BVS("argv",8)
    exploited = p.loader.main_object.get_symbol(
        'svcunix_create_vuln')

    path = claripy.BVS("path",8*200)
    #state = p.factory.full_init_state(args=[elf_binary,argv])
    state = p.factory.call_state(exploited.rebased_addr,path)#addr=exploited.rebased_addr
    state.options.add(angr.options.LAZY_SOLVES)
    state.libc.buf_symbolic_bytes = 0x200
    state.libc.max_variable_size = 0x200
    state.libc.max_str_len = 150# fuck that shit, our string can be bigger than the default of 128, only at around 140bytes will the bof trigger
    #state.symbo
    #state.add_constraints(argv.get_byte(0) <0)
    #state.add_constraints(argv.get_byte(0) == 0x3F)
    
    print(state.registers)
    simgr = p.factory.simulation_manager(state, save_unconstrained=True)
    simgr.stashes['mem_corrupt']  = []

    cfg = p.analyses.CFG(fail_fast=True)

    def getFuncAddress( funcName, plt=None ):
        found = [
            addr for addr,func in cfg.kb.functions.items()
            if funcName == func.name and (plt is None or func.is_plt == plt)
            ]
        if len( found ) > 0:
            print("Found "+funcName+"'s address at "+hex(found[0])+"!")
            return found[0]
        else:
            raise Exception("No address found for function : "+funcName)

    #addrStrcpy = getFuncAddress('memcpy', plt=True)
    '''
        Since we want to find a path to strcpy ONLY where we have control of the
        source buffer, we have to have a custom check function which takes a Path
        as an argument.
        You might be wondering what we should do to instruct angr to find our
        target address since we're replacing the 'find=' argument with this
        'check' function.  Just check p.state.ip.args[0] (the current instruction
        pointer) to make sure we're at our intended path destination before checking
        to make sure the other conditions are satisfied.
        '''
    def check(state):
        print(state.ip.args[0] )
        if (state.ip.args[0] == addrStrcpy):    # Ensure that we're at strcpy
            print("keku")
            '''
                By looking at the disassembly, I've found that the pointer to the
                source buffer given to strcpy() is kept in RSI.  Here, we dereference
                the pointer in RSI and grab 8 bytes (len("HAHAHAHA")) from that buffer.
            '''
            print("lel",len(argv)/8)
            BV_strCpySrc = state.memory.load( state.regs.rsi, 200 )
            '''
                Now that we have the contents of the source buffer in the form of a bit
                vector, we grab its string representation using the current state's
                solver engine's function "eval" with cast_to set to str so we get a python string.
            '''
            strCpySrc = state.solver.eval( BV_strCpySrc , cast_to=bytes )
            print("content",strCpySrc)
            print("solv",state.solver.eval(argv , cast_to=bytes ))
            '''
                Now we simply return True (found path) if we've found a path to strcpy
                where we control the source buffer, or False (keep looking for paths) if we
                don't control the source buffer
            '''
            return False
        else:
            '''
                If we aren't in the strcpy function, we need to tell angr to keep looking
                for new paths.
            '''
            return False

    
    #simgr.explore()#check,avoid=0x4016a2)



    IPython.embed()
    
if __name__ == "__main__":
    main()